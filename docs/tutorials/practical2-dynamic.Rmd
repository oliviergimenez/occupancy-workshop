---
title: "Practical 2: Dynamic model"
author: "Olivier Gimenez"
output:
  html_document:
    highlight: tango
    number_sections: yes
    theme: spacelab
    toc: yes
    toc_depth: 2
date: "May 2023"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      message = FALSE, 
                      warning = FALSE,
                      cache = TRUE,
                      dpi = 300, 
                      fig.height = 6, 
                      fig.width = 1.777777*6)
```

# Objectives

+ Fit dynamic (multi-season) occupancy models
+ Map occupancy

# Pre-requisites

Load some packages:
```{r}
library(tidyverse) # manipulate and visulaize data
theme_set(theme_light(base_size = 16)) # set theme for visualisation and font size
library(unmarked) # occupancy modelling
library(sf) # spatial dataviz
```

# Data

We use data from *Mapping and explaining wolf recolonization in France using dynamic occupancy models and opportunistic data* by Louvrier et al. in Ecography available at <https://onlinelibrary.wiley.com/doi/abs/10.1111/ecog.02874>. Data were collected between 1994 and 2017 (23 years or primary occasion). Occasions are months December, January, February and March (4 visits or secondary occasions). A 100km$^2$ grid was overlaid over France and detections and non-detections were collected. See paper for more details. 

## Read in data

First detection/non-detection data:
```{r}
y <- readRDS("data/wolf_louvrier.rds")
dim(y)
```

There are > 3000 cells in row. In columns we have 23 years * 4 visits, arranged in visits within year format, that is visit 1 to visit 4 for year 1994 in the first four columns, then visit 1 to visit 4 for year 1995, and so on.

Now read in some covariates data. First the survey effort which is (approx) the number of observers per cell:  
```{r}
effort <- readRDS("data/effort_louvrier.rds")
```

The effort covariate is a yearly site-level covariate, with values that do not vary between visits within a year, but that do vary between years:
```{r}
dim(effort)
```

We have some environmental covariates as well, all site-level covariates:
```{r}
envcov <- readRDS("data/envcov_louvrier.rds")
```

The 7 covariates are specifically in column: farmland cover, altitude, distance to closest barrier, road density, forest cover, high altitude, rock cover:
```{r}
colnames(envcov)
```

Last, we have two additional yearly site-level covariates which capture dispersal abilities of wolves, namely the number of occupied neighboring cells at short (10km) and long (150km) distance:
```{r}
# short distance
SDAC <- readRDS("data/shortd_spatialautocorr.rds")
# long distance 
LDAC <- readRDS("data/longd_spatialautocorr.rds")
```

## Format data

Site-level covariates first:
```{r}
sites.covs <- data.frame(
  forest = envcov[,"p_forest"], # forest cover
  agr = envcov[,"p_agri"], # farmland cover
  rock = envcov[,"p_rock"], # rock cover
  halt = envcov[,"p_halt"], # high altitude
  alt = envcov[,"p_alti"], # altitude
  dbarr = envcov[,"p_dbarr"], # distance to closest barrier
  acc = envcov[,"p_road"]) # road density
```

On rassemble les covariables dont les valeurs diffèrent selon la cellule et l'année.
```{r}
year <- matrix(rep(c('01','02','03','04','05','06','07','08','09','10','11','12','13','14','15','16','17','18','19','20','21','22','23'),nrow(y)), 
               nrow = nrow(y), 
               ncol = 23, 
               byrow = TRUE)
head(year)
```


```{r}
trendyear <- matrix(rep(1:23,nrow(y)), 
                    nrow=nrow(y),
                    ncol=23, 
                    byrow=TRUE)
head(trendyear)
```

Yearly site-level covariates:
```{r}
yearly.site.covs <- list(
  effort = effort, # effort
  year = year, # year effect
  trendyear = trendyear, # linear trend over time
  SDAC = SDAC, # short distance
  LDAC = LDAC) # long distance
```

On rassemble les covariables dont les valeurs diffèrent selon les occasions secondaires.
```{r}
occ <- array(0,c(3450,4,23))
for (i in 1:3450){
	for (j in 1:23){
		occ[i,1:4,j] <- c('1','2','3','4') # dec, jan, feb, mar
		if (effort[i,j] == 0) occ[i,1:4,j] <- NA
				}
	}
occbis <- occ[,,1]
for (i in 2:23){
	occbis <- cbind(occbis,occ[,,i])
}
dim(occbis) # 3450 x 92 ou 92 est 4 occ x 23 ans
obs.covs <- list(OCC = occbis)
```

Organise detection/non-detection data and covariates in `data.frame` that can be used by `unmarked`: 
```{r}
umf <- unmarkedMultFrame(y = y, 
                         siteCovs = sites.covs,
                         yearlySiteCovs = yearly.site.covs, 
                         obsCovs = obs.covs,
                         numPrimary = 23)
```

Summarize data:
```{r}
summary(umf)
```

# Model with constant parameters, except detection which is a function of effort

Fit a model with all parameters constant,but detection which is a function of effort:
```{r}
fm0 <- colext(
  psiformula = ~ 1,     # initial occupancy
  gammaformula =  ~ 1,  # colonization
  epsilonformula = ~ 1, # extinction
  pformula = ~ effort,  # detection
  data = umf, # data
  control = list(trace = 1)) # display number of iterations by blocks of 10
```

Inspect results:
```{r}
fm0
```

Model coefficients (or parameters):
```{r}
coef(fm0)
```

Get parameter estimates on natural scale. Start with colonization:
```{r}
backTransform(fm0, type = "col")
```

Then extinction:
```{r}
backTransform(fm0, type = "ext")
```

And initial occupancy:
```{r}
backTransform(fm0, type = "psi")
```

Finally, we get detection as a function of effort:
```{r}
# grid
effort_grid <- seq(min(yearly.site.covs$effort), max(yearly.site.covs$effort), length = 100)
# predict on logit scale
logit_det <- coef(fm0)[4] + coef(fm0)[5] * effort_grid
# backtransform
det <- plogis(logit_det)
# plot
plot(x = effort_grid, 
     y = det, 
     type = 'l', 
     xlab = "effort", 
     ylab = "estimated detection probability", 
     lwd= 3)
```

# Model with all covariates as in the Louvrier et al paper

Here we fit the model with all covariates as considered by Louvrier and colleagues in their paper:
```{r}
fm <- colext(
  psiformula = ~ 1,                                            # initial occupancy
  gammaformula =  ~ forest + agr + halt + alt + SDAC + LDAC,  # colonization
  epsilonformula = ~ 1,                                       # extinction
  pformula = ~ effort + acc + OCC,                                # detection
  data = umf, # data
  control = list(trace = 1), # display number of iterations by blocks of 10
  se = FALSE) # do not compute SE and confidence intervals to reduce computational burden
```

Inspect results (NA's are produced because we did not compute SE's when we fitted the model):
```{r}
fm
```

Model coefficients are:
```{r}
coef(fm)
```
Parameter estimates are given on the logit scale. You may compare them to those obtained by Louvrier and colleagues using a Bayesian approach.

# Map occupancy

There are two ways to map annual occupancy. We may compute the occupancy probability $\psi_{i,t}$, or we rely directly on realized occupancy, that is the latent state $z_{i,t}$ which tells us whether cell $i$ is occupied in year $t$ ($z_{i,t} = 1$) or not ($z_{i,t} = 0$). We go for realized occupancy. To do so, we need the $z$ estimates that we can get in `unmarked` via empirical Bayes methods: The posterior distribution of $z$ is estimated with data and the parameter estimates we obtained from fitting our model above. The mode of the posterior distribution is the "empirical best unbiased predictor (EBUP)". 
```{r}
re <- ranef(fm) # estimate posterior distribution of z
z_mode <- bup(re, stat = "mode") # get mode of posterior distribution
```

L'objet `z_mode` contient les $z$ estimés avec en lignes les cellules de la grille et en colonnes les années. Mettons tout ça sur une carte. 

Get a map of France:
```{r}
france <-  st_read("shp/pays/Country.shp")
```

then our 10x10km grid: 
```{r}
grid_rect <- st_read("shp/grille10par10/grille_France.shp") %>% 
  st_transform(crs = st_crs(france))
```

On récupère les coordonnées de nos cellules échantillonnées au moins une fois au cours de l'étude.
```{r}
coord <- readRDS("data/coordcells_wolf.rds")
grid <- coord %>% 
  st_as_sf(coords = c('X','Y'), crs = st_crs(grid_rect))
```

L'objet `grid` ainsi créé est un objet spatial `sf` de type `POINT`, il me faudrait plutôt des `POLYGONS` pour les représenter en couleur sur la grille. 
```{r}
grid_poly <- st_join(grid_rect, grid, join = st_covers)
grid_poly <- grid_poly[!is.na(grid_poly$id),]
```

Enfin, une carte ! On prend l'année 2017 la plus récente dans le jeu de données. 
```{r}
grid_rect %>% 
  ggplot() + 
  geom_sf(alpha = 0, lwd = 0.01) + 
  geom_sf(data = grid_poly, aes(fill = as_factor(z_mode[,23])), 
          lwd = 0.01) + 
  geom_sf(data = france %>% filter(NAME == "France"), alpha = 0) +
  scale_fill_manual(name = "",
                    values = c("gray90",
                               "steelblue1"),
                    labels = c("cellule non-occupée", 
                               "cellule occupée")) +
  labs(title = "Carte de l'occupancy du loup en 2017",
       subtitle = "Données réseau loup")
```

Construisons une fonction qui fait la carte de l'occupancy pour une année quelconque. Cette fonction prend comme argument *year* entre 1995 et 2017.
```{r}
occ_plot <- function(year){
  if (year < 1995) stop("Le loup venait juste d'arriver, pas la peine d'en faire une carte")
  if (year > 2017) stop("Pas de données aussi récentes, va falloir attendre")
  index <- year - 1994
  grid_rect %>% 
  ggplot() + 
  geom_sf(alpha = 0, lwd = 0.01) + 
  geom_sf(data = grid_poly, aes(fill = as_factor(z_mode[,index])), 
          lwd = 0.01) + 
  geom_sf(data = france %>% filter(NAME == "France"), alpha = 0) +
  scale_fill_manual(name = "",
                    values = c("gray90",
                               "steelblue1"),
                    labels = c("non-occupée", 
                               "occupée")) +
  labs(subtitle = year) +
  theme(legend.position = "none")  
}
```

On fait un essai avec l'année 2016.
```{r}
occ_plot(2016)
```

On fait 3 cartes pour les années 2000, 2010 et 2017.
```{r}
library(patchwork)
plot_list <- lapply(X = c(2000, 2010, 2017), FUN = occ_plot)
plot_list[[1]] | plot_list[[2]] | plot_list[[3]]
```
